import crypto from 'crypto';

type RequiredEnvVar = {
  name: string;
  description: string;
  canGenerate?: boolean; // If true, we can auto-generate a secure value
};

// Generate a cryptographically secure random string
function generateSecureSecret(bytes = 32): string {
  return crypto.randomBytes(bytes).toString('hex');
}

// Auto-generated secrets storage (for runtime consistency)
const generatedSecrets: Record<string, string> = {};

export function getOrGenerateSecret(name: string): string {
  // Check environment first
  const envValue = process.env[name];
  if (envValue && envValue.trim()) return envValue;
  
  // Return previously generated value for consistency
  if (generatedSecrets[name]) return generatedSecrets[name];
  
  // Generate new secret
  const newSecret = generateSecureSecret();
  generatedSecrets[name] = newSecret;
  // Also set in process.env so other modules can access it
  process.env[name] = newSecret;
  return newSecret;
}

export function validateProductionEnv(): void {
  if (process.env.NODE_ENV !== 'production') return;

  // If ALLOWED_ORIGINS isn't explicitly set, infer a safe default from known deployment URLs.
  // This prevents boot failures on Render when the service env vars weren't fully configured,
  // while still avoiding wildcard origins with credentials.
  const rawAllowedOrigins = (process.env.ALLOWED_ORIGINS || '').trim();
  if (!rawAllowedOrigins) {
    const candidates: string[] = [];
    const baseUrl = (process.env.BASE_URL || '').trim();
    const renderExternalUrl = (process.env.RENDER_EXTERNAL_URL || '').trim();
    const renderExternalHostname = (process.env.RENDER_EXTERNAL_HOSTNAME || '').trim();

    const normalize = (u: string) => {
      const trimmed = u.trim();
      if (!trimmed) return '';
      const noSlash = trimmed.replace(/\/$/, '');
      return noSlash.replace(/^http:\/\//i, 'https://');
    };

    if (baseUrl) candidates.push(normalize(baseUrl));
    if (renderExternalUrl) candidates.push(normalize(renderExternalUrl));
    if (renderExternalHostname) candidates.push(normalize(`https://${renderExternalHostname}`));

    const inferred = Array.from(new Set(candidates.filter(Boolean)));
    if (inferred.length > 0) {
      process.env.ALLOWED_ORIGINS = inferred.join(',');
    }
  }

  const required: RequiredEnvVar[] = [
    {
      name: 'DATABASE_URL',
      description: 'PostgreSQL connection string (Render External Database URL)',
      canGenerate: false,
    },
    {
      name: 'JWT_SECRET',
      description: 'JWT signing secret for session cookies/refresh tokens',
      canGenerate: true,
    },
    {
      name: 'ALLOWED_ORIGINS',
      description: 'Comma-separated allowlist for credentialed CORS requests',
      canGenerate: false,
    },
    {
      name: 'ENCRYPTION_KEY',
      description: 'App-level encryption key (2FA secrets, sensitive fields)',
      canGenerate: true,
    },
    {
      name: 'UPLOAD_SIGNING_KEY',
      description: 'HMAC key used to sign expiring upload URLs',
      canGenerate: true,
    },
  ];

  // Auto-generate secrets that can be generated
  const autoGenerated: string[] = [];
  for (const v of required) {
    if (v.canGenerate && !(process.env[v.name] && process.env[v.name]!.trim())) {
      getOrGenerateSecret(v.name);
      autoGenerated.push(v.name);
    }
  }

  if (autoGenerated.length > 0) {
    console.warn('⚠️  Auto-generated secrets for this session (set these in Render dashboard for persistence):');
    for (const name of autoGenerated) {
      console.warn(`   - ${name}`);
    }
    console.warn('   Note: Auto-generated secrets change on each restart. Set them manually for stable sessions/tokens.');
  }

  // Check remaining required vars that cannot be auto-generated
  const missing = required.filter(
    (v) => !v.canGenerate && !(process.env[v.name] && process.env[v.name]!.trim())
  );

  const dbUrl = (process.env.DATABASE_URL || '').trim();
  const dbUrlInvalid = Boolean(dbUrl) && !/^postgres(ql)?:\/\//i.test(dbUrl);
  const allowedOrigins = (process.env.ALLOWED_ORIGINS || '').trim();
  const originInvalid = allowedOrigins === '*' || allowedOrigins.includes('://*');

  if (missing.length === 0 && !originInvalid && !dbUrlInvalid) return;

  const lines: string[] = [];
  lines.push('❌ Production configuration error');
  lines.push('The server refuses to start because required environment variables are missing or unsafe.');
  lines.push('');

  if (missing.length > 0) {
    lines.push('Missing:');
    for (const v of missing) {
      lines.push(`- ${v.name}: ${v.description}`);
    }
    lines.push('');
  }

  if (originInvalid) {
    lines.push('Invalid:');
    lines.push('- ALLOWED_ORIGINS must not be a wildcard when using credentialed cookies');
    lines.push('');
  }

  if (dbUrlInvalid) {
    lines.push('Invalid:');
    lines.push('- DATABASE_URL must start with postgres:// or postgresql:// (Render: use Internal Database URL / Add-from-database)');
    lines.push('');
  }

  throw new Error(lines.join('\n'));
}
