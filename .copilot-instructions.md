# Copilot Instructions — React Template System for Store Builder

You are assisting in building a multi-template store platform using React, Vite, and Node.js.
Each store template is a React component that renders the same data in different layouts.

Your job is to understand how templates work, how they switch, and how to generate new ones
based on screenshots provided by the developer.

===========================================================
SECTION 1 — UNIVERSAL DATA CONTRACT (MANDATORY)
===========================================================

All templates must use the same data structure:

```typescript
store = {
  store_name: string,
  logo: string,
  primary_color: string,
  secondary_color: string,
  hero_image: string,
  featured_products: Product[],
  categories: string[]
}

products = [
  {
    id: string,
    title: string,
    description: string,
    price: number,
    images: string[],
    variants: any[],
    tags: string[]
  }
]
```

Templates must accept:
```jsx
<TemplateX store={store} products={products} />
```

Templates must NEVER:
- create new fields
- rename fields
- modify the schema
- depend on template-specific data

===========================================================
SECTION 2 — TEMPLATE BEHAVIOR
===========================================================

Each template is a React component that defines ONLY:
- layout
- styling
- component arrangement
- visual hierarchy

Templates must export:

```typescript
export const templateMetadata = {
  name: string,
  version: string,
  preview_image: string,
  description: string
};

export default function TemplateX({ store, products }) {
  // Only layout rendering here
  return JSX;
}
```

Templates must be visually identical to the screenshot provided.

Do NOT add business logic, data fetching, or state management.

===========================================================
SECTION 3 — TEMPLATE SWITCHING RULES
===========================================================

Switching templates means:
- same data
- different layout
- zero data loss

No migration.
No conversion.
No schema changes.

Smart mapping rules:
- `store.hero_image` → hero/banner section
- `store.featured_products` → featured/showcase section
- `product.images[0]` → main product image
- `product.images[1..]` → gallery/carousel
- `store.primary_color` → main accent/CTA buttons
- `store.secondary_color` → secondary accents/badges
- `product.price` → price display (format as needed per template)
- `product.tags` → product badges/labels
- `categories` → navigation/filters (if applicable)

When user switches templates:
- Pass exact same store + products objects
- Template re-renders with new layout
- All data appears instantly
- No API calls needed

===========================================================
SECTION 4 — TEMPLATE CREATION RULES
===========================================================

When the developer provides a screenshot:
- Recreate the layout exactly in React
- Use the universal data contract (store + products only)
- Use JSX + Tailwind CSS (matches project)
- Keep the structure clean and modular
- Use component composition for reusability
- Do NOT add logic outside layout rendering
- Ensure responsive design (mobile-first)
- Include dark mode support if in project

When the developer provides existing template code:
- Improve structure and modularity
- Fix layout issues
- Ensure compatibility with switching rules
- Keep the visual design identical
- Verify it uses store + products correctly
- Remove any hardcoded data

Template file naming: `/client/components/templates/Template[Name].tsx`

===========================================================
SECTION 5 — TEMPLATE STRUCTURE EXAMPLE
===========================================================

```typescript
// /client/components/templates/TemplateMinimalist.tsx

export const templateMetadata = {
  name: "Minimalist",
  version: "1.0",
  preview_image: "/templates/minimalist.png",
  description: "Clean, simple product listing"
};

interface TemplateProps {
  store: {
    store_name: string;
    logo: string;
    primary_color: string;
    secondary_color: string;
    hero_image: string;
    featured_products: Product[];
    categories: string[];
  };
  products: Product[];
}

interface Product {
  id: string;
  title: string;
  description: string;
  price: number;
  images: string[];
  variants: any[];
  tags: string[];
}

export default function TemplateMinimalist({ store, products }: TemplateProps) {
  return (
    <div className="min-h-screen bg-white dark:bg-black">
      {/* Hero Section */}
      <section className="relative h-96">
        <img src={store.hero_image} alt={store.store_name} className="w-full h-full object-cover" />
        <div className="absolute inset-0 bg-black/30 flex items-center justify-center">
          <h1 className="text-4xl font-bold text-white">{store.store_name}</h1>
        </div>
      </section>

      {/* Products Grid */}
      <section className="container mx-auto px-4 py-16">
        <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-6">
          {products.map(product => (
            <ProductCard key={product.id} product={product} primaryColor={store.primary_color} />
          ))}
        </div>
      </section>
    </div>
  );
}

function ProductCard({ product, primaryColor }: { product: Product; primaryColor: string }) {
  return (
    <div className="border rounded-lg overflow-hidden hover:shadow-lg transition">
      <img src={product.images[0]} alt={product.title} className="w-full h-48 object-cover" />
      <div className="p-4">
        <h3 className="font-semibold">{product.title}</h3>
        <p className="text-sm text-gray-600 mt-1">{product.description}</p>
        <div className="flex justify-between items-center mt-4">
          <span className="font-bold">${product.price}</span>
          <button
            className="px-3 py-1 rounded text-white"
            style={{ backgroundColor: primaryColor }}
          >
            Add to Cart
          </button>
        </div>
      </div>
    </div>
  );
}
```

===========================================================
SECTION 6 — COPILOT WORKFLOW
===========================================================

**When the developer pastes a new template file:**
1. Understand it as a React layout component
2. Ensure it follows the data contract (store + products props)
3. Ensure it supports template switching (no modifications to data)
4. Verify smart mapping rules are used (hero_image, featured_products, etc.)
5. Check responsive design and dark mode support
6. Suggest improvements if structure can be cleaner
7. Do NOT add business logic or API calls

**When the developer asks for a new template:**
1. Ask for a screenshot or description of the layout
2. Generate a React component following all rules above
3. Match the screenshot exactly
4. Use the same naming conventions (templateMetadata + default export)
5. Include TypeScript interfaces for props
6. Add component composition for reusability
7. Ensure it uses store + products only

**When reviewing template code:**
1. Verify universal data contract is followed
2. Check for no hardcoded data
3. Check for no API calls or side effects
4. Verify responsive and dark mode support
5. Ensure component exports metadata
6. Suggest modularity improvements

===========================================================
SECTION 7 — TEMPLATE SWITCHING IMPLEMENTATION
===========================================================

In the storefront component:

```typescript
const [templateName, setTemplateName] = useState('minimalist');
const Template = templateMap[templateName]; // Dynamically import templates

return <Template store={store} products={products} />;
```

Switching is instant because:
- Same data passed to different component
- No re-fetch needed
- Pure React re-render

===========================================================
SECTION 8 — DO's AND DON'Ts
===========================================================

✅ DO:
- Use only store + products props
- Keep layouts clean and modular
- Use Tailwind CSS for styling
- Support responsive design
- Support dark mode
- Export metadata
- Use TypeScript interfaces
- Map smart rules (hero_image → hero section)

❌ DON'T:
- Create custom fields
- Rename contract fields
- Add API calls
- Add state management
- Add business logic
- Hardcode data
- Modify the schema
- Add authentication logic
- Add shopping cart logic

===========================================================

**This file lives in the project root and should be referenced by all template work.**

When pasting a template → Copilot checks this file.
When generating a template → Copilot follows this file.
When reviewing a template → Copilot validates against this file.

End of instructions.
